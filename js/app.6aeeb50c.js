(function(e){function t(t){for(var a,i,s=t[0],l=t[1],u=t[2],d=0,h=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&h.push(r[i][0]),r[i]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a]);c&&c(t);while(h.length)h.shift()();return o.push.apply(o,u||[]),n()}function n(){for(var e,t=0;t<o.length;t++){for(var n=o[t],a=!0,s=1;s<n.length;s++){var l=n[s];0!==r[l]&&(a=!1)}a&&(o.splice(t--,1),e=i(i.s=n[0]))}return e}var a={},r={app:0},o=[];function i(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=e,i.c=a,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)i.d(n,a,function(t){return e[t]}.bind(null,a));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/revue/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],l=s.push.bind(s);s.push=t,s=s.slice();for(var u=0;u<s.length;u++)t(s[u]);var c=l;o.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("cd49")},"0a4f":function(e,t){const n=[{title:"Maximum Subarray",tags:["easy","array","dynamic programming"],description:"Given an integer array, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",example:"Input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nOutput: 6\nExplanation: [4, -1, 2, 1] has the largest sum, 6.\n",explanation:"**Kadane's algorithm:**\n\nKeep two maximums: a local maximum that represents the maximum contiguous subarray sum up to a particular element, and a global maximum\nof all the local maximums seen so far.\n\nAt each element in your traversal, accept and add to the previous local max if its sum with the current element is better than starting\nthe local max over at that element.\n",solution:"```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        global_max = local_max = nums[0]\n        for i in range(1, len(nums)):\n            local_max = max(local_max + nums[i], nums[i])\n            global_max = max(global_max, local_max)\n        return global_max\n```\n"}];e.exports=n.length<=1?n[0]:n},"2a22":function(e,t,n){"use strict";var a=n("df02"),r=n.n(a);r.a},"3d35":function(e,t){const n=[{title:"In-order Traversal",tags:["easy","bst","recursion"],description:"Given a binary tree, return the inorder traversal of its nodes' values.",example:"Input: [1,null,2,3]\n  1\n   \\\n    2\n   /\n  3\nOutput: [1,3,2]\n",explanation:"One of the simplest examples of recursion on a binary tree. For in-order traversal, think *Left-Root-Right*.\n\nIntuitively, I think of it as traversing as far left on the tree as possible, then incrementally popping back up the stack to \nvisit each most recent root and repeating this process on the right subtree of that root.\n\nIn-order traversal of a BST retrieves data **in** sorted **order** precisely because the binary search property specifies that \neach node must be greater than or equal to any node in its left subtree, and less than or equal to any node in its right subtree.\n\n**Formally:**\n1. Check if root is null\n2. Traverse the left subtree recursively\n3. Visit the root (could be printing or storing the value)\n4. Traverse the right subtree recursively\n",solution:"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        result = []\n        self.inorderHelper(root, result)\n        return result\n    \n    def inorderHelper(self, root: TreeNode, accumulator: List[int]):\n        if root:\n            if root.left:\n                self.inorderHelper(root.left, accumulator)\n            accumulator.append(root.val)\n            if root.right:\n                self.inorderHelper(root.right, accumulator)\n```\n"}];e.exports=n.length<=1?n[0]:n},"3eea":function(e,t){const n=[{title:"Word Ladder",tags:["medium","bfs"],description:'Given two words (*beginWord* and *endWord*), and a "dictionary" word list, find the length of the shortest transformation sequence possible from *beginWord* to *endWord*, such that:\n1. Only one letter can be changed at a time.\n2. Each transformed word must exist in the word list. Note that *beginWord* is not a transformed word.\n\n- Return 0 if there is no such transformation sequence.\n- All words have the same length.\n- All words contain only lowercase alphabetic characters.\n- You may assume no duplicates in the word list.\n- You may assume *beginWord* and *endWord* are non-empty and are not the same.\n',example:'Input:\nbeginWord = "hit",\nendWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\n\nOutput: 5\n\nExplanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.\n',explanation:'View this as a graph search problem where vertices are the words in your "dictionary" and edges connect vertices whose words differ by a single character. \nThus, a shortest transformation sequence from `beginWord` to `endWord` is equivalent to a shortest path between the two words\' representative graph vertices. \n\nSolving for an unweighted shortest path suggests BFS. We can build a graph of possible transformations from `beginWord` to `endWord` by, at every word along the \ntraversal, enumerating all words differing from that word by a single character, and adding them to our search space if they exist in the word list.\n\nWe can keep track of the path length by storing the cumulative traversal length along with each word in our frontier queue.\n',solution:"```python\nfrom typing import Set, Iterator\nfrom collections import deque\nimport string\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        q = deque([(beginWord, 1)])\n        seen = set([beginWord])\n        word_list = set(wordList)\n        while q:\n            current = q.popleft()\n            for candidate in self.generateNeighbors(current[0], word_list):\n                if candidate == endWord:\n                    return current[1] + 1\n                if candidate not in seen:\n                    seen.add(candidate)\n                    q.append([candidate, current[1] + 1])\n        return 0\n\n    def generateNeighbors(self, word: str, wordList: Set[str]) -> Iterator[str]:\n        for i in range(len(word)):\n            for letter in string.ascii_lowercase:\n                candidate = word[:i] + letter + word[i+1:]\n                if candidate in wordList:\n                    yield candidate\n```\n"}];e.exports=n.length<=1?n[0]:n},"41c1":function(e,t){const n=[{title:"Best Time to Buy and Sell Stock",tags:["easy","array","greedy"],description:"Say you have an array for which the i-th element is the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design \nan algorithm to find the maximum profit.\n\nNote that you cannot sell a stock before you buy one.\n",example:"Input: [7, 1, 5, 3, 6, 4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNot 7-1 = 6, as selling price needs to be larger than buying price.\n",explanation:"A brute-force strategy would involve finding the max value of `prices[j] - prices[i]` for every `i, j` such that `j > i`.\n\nWe can avoid a quadratic brute-force solution by employing a greedy strategy that has the same effect using one pass. The intuition here is to \nkeep track of the the minimum price seen so far in the traversal. This minimum price when subtracted from the current element yields the maximum \nprofit achievable up to that element. Keep track of the maximum profit seen over the course of the entire traversal, which will be the global\nmaximum profit. \n",solution:"```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        max_profit = 0\n        low = float('inf')\n        for price in prices:\n            if price < low:\n                low = price\n            elif price - low > max_profit:\n                max_profit = price - low\n        return max_profit\n```\n"}];e.exports=n.length<=1?n[0]:n},"94ff":function(e,t,n){var a={"./bitonicarraymax.yaml":"ff72","./inorder.yaml":"3d35","./maxprofit.yaml":"41c1","./maxsubarray.yaml":"0a4f","./pathsum.yaml":"962f","./twosum.yaml":"f21b","./wordladder.yaml":"3eea"};function r(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id="94ff"},"962f":function(e,t){const n=[{title:"Path Sum",tags:["easy","bst","recursion"],description:"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.",example:"Given the below binary tree and sum = 22,\n        5\n       / \\\n      4   8\n     /   / \\\n    11  13  4\n   /  \\      \\\n  7    2      1\nreturn true, as there exists a root-to-leaf path 5->4->11->2 whose sum is 22.\n",explanation:"Classic example of recursion on a BST. Given the example tree rooted at 5, asking if there is a root-to-leaf path with value sum 22 \nis equivalent to asking if there is a root-to-leaf path with value sum 17 (22 - 5, the value of the root) for either of the left or right \nsubtrees of the root.\n\nThis intuition can guide us in enumerating our base and recursive cases.\n- **Base cases**:\n  1. If root is null, we cannot satisfy any path sum. \n  2. If root is a leaf, we trivially satisfy a path sum if the target sum equals the value of the root.\n- **Recursive case**:\n  - Does either of our left or right subtrees have a path sum of the target sum minus the value of the root?\n",solution:"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        if not root:\n            return False\n        if not (root.left or root.right) and sum == root.val:\n            return True\n        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)\n```\n"}];e.exports=n.length<=1?n[0]:n},a585:function(e,t,n){"use strict";var a=n("b100"),r=n.n(a);r.a},b100:function(e,t,n){},cd49:function(e,t,n){"use strict";n.r(t);n("e260"),n("e6cf"),n("cca6"),n("a79d");var a=n("2b0e"),r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("v-app",[n("Topbar"),n("Frame")],1)],1)},o=[],i=n("9f12"),s=n("8b83"),l=n("c65a"),u=n("c03e"),c=n("9ab4"),d=n("60a3"),h=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("v-card",{staticClass:"overflow-hidden",attrs:{tile:""}},[n("v-app-bar",{attrs:{color:"#fcb69f",dark:"",prominent:"",src:"https://picsum.photos/1920/1080?random"},scopedSlots:e._u([{key:"img",fn:function(t){var a=t.props;return[n("v-img",e._b({attrs:{gradient:"to top right, rgba(19,84,122,.5), rgba(128,208,199,.8)"}},"v-img",a,!1))]}}])},[n("v-toolbar-title",{staticClass:"display-2"},[e._v("revue")]),n("v-spacer"),n("v-btn",{attrs:{icon:"",href:"https://github.com/williamvwang/revue",target:"_blank"}},[n("v-icon",[e._v("fab fa-github")])],1)],1)],1)},f=[],p=function(e){function t(){return Object(i["a"])(this,t),Object(s["a"])(this,Object(l["a"])(t).apply(this,arguments))}return Object(u["a"])(t,e),t}(d["b"]);p=c["a"]([Object(d["a"])({})],p);var m=p,g=m,v=n("2877"),b=n("6544"),y=n.n(b),x=n("40dc"),w=n("8336"),_=n("b0af"),O=n("132d"),k=n("adda"),C=n("2fa4"),S=n("2a7f"),j=Object(v["a"])(g,h,f,!1,null,null,null),q=j.exports;y()(j,{VAppBar:x["a"],VBtn:w["a"],VCard:_["a"],VIcon:O["a"],VImg:k["a"],VSpacer:C["a"],VToolbarTitle:S["a"]});var T=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("v-content",[n("v-container",{staticClass:"mt-12"},[n("v-row",[n("v-col",{attrs:{cols:"12",md:"3"}},[n("v-card",{staticClass:"mx-auto mb-6",attrs:{tile:""}},[n("v-card-title",{staticClass:"pb-0"},[e._v("Filter")]),n("v-card-actions",{staticClass:"pa-4"},[n("v-chip-group",{attrs:{column:"",multiple:"","active-class":"primary--text"},model:{value:e.tagSelections,callback:function(t){e.tagSelections=t},expression:"tagSelections"}},e._l(e.tags,(function(t){return n("v-chip",{key:t,attrs:{filter:"",value:t}},[e._v(" "+e._s(t)+" ")])})),1)],1)],1),n("v-card",{staticClass:"mx-auto",attrs:{tile:""}},[n("v-list",{staticClass:"overflow-y-auto",staticStyle:{"max-height":"50vh"},attrs:{flat:"","two-line":""}},[n("v-list-item-group",{attrs:{color:"primary"},model:{value:e.question,callback:function(t){e.question=t},expression:"question"}},e._l(e.filteredQuestions,(function(t,a){return n("v-list-item",{key:a,attrs:{value:t}},[n("v-list-item-content",[n("v-list-item-title",{domProps:{textContent:e._s(t.title)}}),n("v-chip-group",{attrs:{column:""}},e._l(t.tags,(function(t){return n("v-chip",{key:t},[e._v(" "+e._s(t)+" ")])})),1)],1)],1)})),1)],1)],1)],1),n("v-col",{attrs:{cols:"12",md:"9"}},[n("QuestionDetail",{attrs:{question:e.question}})],1)],1)],1)],1)},V=[],L=(n("a623"),n("4de4"),n("4160"),n("caad"),n("d81d"),n("d3b7"),n("6062"),n("2532"),n("3ca3"),n("159b"),n("ddb0"),n("53fe")),I=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("v-card",{staticClass:"mx-auto",attrs:{tile:""}},[e.question?n("v-card-text",[n("p",{staticClass:"display-1 text--primary"},[e._v(e._s(e.question.title))]),n("v-divider"),n("v-card-subtitle",{staticClass:"pb-0"},[e._v("Tags")]),n("v-card-text",{staticClass:"pb-0"},[n("v-chip-group",{attrs:{column:""}},e._l(e.question.tags,(function(t){return n("v-chip",{key:t},[e._v(" "+e._s(t)+" ")])})),1)],1),n("v-card-subtitle",{staticClass:"pb-1"},[e._v("Description")]),n("v-card-text",{staticClass:"text--primary pb-0"},[e.question.description?n("div",{domProps:{innerHTML:e._s(e.renderMarkdown(e.question.description))}}):e._e()]),n("v-card-subtitle",{staticClass:"pb-1"},[e._v("Example")]),n("v-card-text",{staticClass:"text--primary"},[n("pre",[e._v(e._s(e.question.example))])]),n("v-card-subtitle",{staticClass:"pb-1"},[e._v("Explanation")]),n("v-card-text",{staticClass:"text--primary pb-0"},[e.question.explanation?n("div",{domProps:{innerHTML:e._s(e.renderMarkdown(e.question.explanation))}}):e._e()]),n("v-card-subtitle",{staticClass:"pb-1"},[e._v("Solution")]),n("v-card-text",{staticClass:"text--primary"},[e.question.solution?n("div",{domProps:{innerHTML:e._s(e.renderMarkdown(e.question.solution,!0))}}):e._e()])],1):e._e()],1)},W=[],N=n("d4cd"),P=n.n(N),M=n("1487"),E=n.n(M),G=(n("6e2e"),function(e){function t(){var e;return Object(i["a"])(this,t),e=Object(s["a"])(this,Object(l["a"])(t).apply(this,arguments)),e.highlighter=new P.a({highlight:function(e,t){if(t&&E.a.getLanguage(t))try{return'<pre class="hljs"><code>'.concat(E.a.highlight(t,e,!0).value,"</code></pre")}catch(n){return""}return""}}),e.md=new P.a,e}return Object(u["a"])(t,e),Object(L["a"])(t,[{key:"renderMarkdown",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t?this.highlighter.render(e):this.md.render(e)}}]),t}(d["b"]));G=c["a"]([Object(d["a"])({props:{question:{type:Object}}})],G);var B=G,A=B,D=(n("a585"),n("99d9")),F=n("cc20"),H=n("ef9a"),R=n("ce7e"),$=Object(v["a"])(A,I,W,!1,null,null,null),Q=$.exports;y()($,{VCard:_["a"],VCardSubtitle:D["b"],VCardText:D["c"],VChip:F["a"],VChipGroup:H["a"],VDivider:R["a"]});var K=function(e){function t(){var e;return Object(i["a"])(this,t),e=Object(s["a"])(this,Object(l["a"])(t).apply(this,arguments)),e.tags=new Set,e.tagSelections=[],e.questionSelection=null,e.question=null,e}return Object(u["a"])(t,e),Object(L["a"])(t,[{key:"created",value:function(){var e=this,t=n("94ff");this.questions=t.keys().map((function(e){var n=t(e);return n.tags=n.tags.map((function(e){return e.toLowerCase()})),n})),this.questions.forEach((function(t){t.tags.forEach((function(t){e.tags.add(t.toLowerCase())}))}))}},{key:"filteredQuestions",get:function(){var e=this;return 0===this.tagSelections.length?this.questions:this.questions.filter((function(t){return e.tagSelections.every((function(e){return t.tags.includes(e)}))}))}}]),t}(d["b"]);K=c["a"]([Object(d["a"])({components:{QuestionDetail:Q}})],K);var J=K,U=J,Y=(n("2a22"),n("62ad")),z=n("a523"),X=n("a75b"),Z=n("8860"),ee=n("da13"),te=n("5d23"),ne=n("1baa"),ae=n("0fd9"),re=Object(v["a"])(U,T,V,!1,null,null,null),oe=re.exports;y()(re,{VCard:_["a"],VCardActions:D["a"],VCardTitle:D["d"],VChip:F["a"],VChipGroup:H["a"],VCol:Y["a"],VContainer:z["a"],VContent:X["a"],VList:Z["a"],VListItem:ee["a"],VListItemContent:te["a"],VListItemGroup:ne["a"],VListItemTitle:te["b"],VRow:ae["a"]});var ie=function(e){function t(){return Object(i["a"])(this,t),Object(s["a"])(this,Object(l["a"])(t).apply(this,arguments))}return Object(u["a"])(t,e),t}(d["b"]);ie=c["a"]([Object(d["a"])({components:{Topbar:q,Frame:oe}})],ie);var se=ie,le=se,ue=n("7496"),ce=Object(v["a"])(le,r,o,!1,null,null,null),de=ce.exports;y()(ce,{VApp:ue["a"]});var he=n("8c4f");a["a"].use(he["a"]);var fe=void 0,pe=new he["a"]({routes:fe}),me=pe,ge=n("f309");a["a"].use(ge["a"]);var ve=new ge["a"]({icons:{iconfont:"fa"}});a["a"].config.productionTip=!1,new a["a"]({router:me,vuetify:ve,render:function(e){return e(de)}}).$mount("#app")},df02:function(e,t,n){},f21b:function(e,t){const n=[{title:"Two Sum",tags:["easy","math","memoization"],description:"Given an array of integers, return indices of the two numbers such that they add up to a specific target.",example:"Given nums = [2, 7, 11, 15] and target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n",explanation:"The simple intuition here is that for any number we come across, there is exactly one number we can add to it to reach the target sum.\n\nIn other words, once we see a number `x`, we know that its complement with the target sum must be `target - x`. Therefore, if we come \nacross another number with value `target - x`, we have found a pair that adds up to our target sum.\n\nTo meet the requirement of returning the indices of this pair, we can maintain a mapping of number to index of occurrence.\nLoop over the array by index -- each time we see a number, check to see if the mapping contains a key whose value is the difference \nbetween the target sum and that number. If so, return the index mapped to by that key and the current index.\n",solution:"```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        value_to_idx = {}\n        for i in range(len(nums)):\n            if target - nums[i] in value_to_idx:\n                return [value_to_idx[target - nums[i]], i]\n            value_to_idx[nums[i]] = i\n        return\n```\n"}];e.exports=n.length<=1?n[0]:n},ff72:function(e,t){const n=[{title:"Bitonic Array Maximum",tags:["easy","array","binary search"],description:"Given an array of integers which is initially monotonically increasing and then monotonically decreasing, find the maximum element. ",example:"Input: [1, 2, 6, 10, 13, 8, 3]\n\nOutput: 13\n",explanation:"This is a variation upon binary search in which we can alter our search condition to search not for a particular predetermined target element, \nbut to look for hints on how to shrink our search space.\n\nIn this case, the inflection point of the array (also the maximum) is the first point at which an array element is greater than the one that \nfollows it. Therefore, if we find a search midpoint such that this property holds true, i.e. `arr[middle] > arr[middle + 1]`, then our new search \nspace must be bounded on the right by `middle`, since any element past it must be less than it and therefore cannot be the maximum. Conversely, \nif this property does not hold true for the midpoint, i.e. `arr[middle] < arr[middle + 1]`, then our new search space must be bounded on the left \nby `middle + 1` -- the maximum cannot lie at `middle` or any point to the left of it because `middle + 1` is greater.\n",solution:"```python\nclass Solution:\n    def bitonicMaximum(self, arr: List[int]) -> int:\n        left, right = 0, len(arr) - 1\n        while left < right:\n            middle = (left + right) // 2\n            if arr[middle] > arr[middle + 1]:\n                right = middle\n            else:\n                left = middle + 1\n        return arr[left]\n```\n"}];e.exports=n.length<=1?n[0]:n}});
//# sourceMappingURL=app.6aeeb50c.js.map